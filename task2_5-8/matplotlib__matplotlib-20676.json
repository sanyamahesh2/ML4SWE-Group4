{
  "Traj ID": "matplotlib__matplotlib-20676",
  "Issue Summary": "The bug arises in Matplotlib's interactive span-selection widget, specifically in the SpanSelector class within lib/matplotlib/widgets.py. When a SpanSelector is created, its helper method _setup_edge_handle instantiates ToolLineHandles, which in turn creates vertical or horizontal lines with ax.axvline/ax.axhline at positions derived from the selector's extents. These handles start at default positions near 0 and trigger autoscaling on the axes, even when the lines are invisible, causing the x-limits (and potentially y-limits) of the axes to change unexpectedly upon widget creation. As a result, simply constructing a SpanSelector (or related handle-based tools) can expand the data limits to include 0 or other handle positions, breaking user-specified zoom or plot ranges. The root cause is that _setup_edge_handle does not preserve or restore the original axis limits around handle creation, allowing autoscale side effects from ToolLineHandles to leak into the main plot state.",
  "Interaction Summary": "The agent began by exploring the Matplotlib repository under /testbed, quickly locating lib/matplotlib/widgets.py and the SpanSelector implementation using view and grep commands. After identifying the initialization path where _setup_edge_handle is called for interactive selectors, the agent drilled into supporting methods such as extents, _draw_shape, and the ToolLineHandles class to reason about how control handles are drawn. To understand the reported regression, the agent created a reproduction script reproduce_issue.py that prints axis limits before and after constructing both interactive and non-interactive SpanSelector instances, confirming that the x-limits expanded unexpectedly. Guided by this evidence, the agent instrumented the code and experimented with autoscaling behavior, ultimately concluding that axvline/axhline calls in ToolLineHandles modify axes limits even when lines are invisible. The agent then implemented a fix in _setup_edge_handle that saves and restores the axes limits around handle creation, and validated this change by running the reproduction script, several additional focused test scripts (for edge cases, Cursor/MultiCursor behavior, and the original PR scenario), plus existing pytest suites before cleaning up temporary files and submitting the patch.",
  "Reproduction Code": "The main reproduction script is reproduce_issue.py, created at step 11 under /testbed. This script imports matplotlib.pyplot and SpanSelector, constructs a simple figure with an Axes plotting the line from (10, 10) to (20, 20), and prints xlim and ylim both before and after creating SpanSelector instances. It first tests the interactive SpanSelector by constructing SpanSelector(ax, print, 'horizontal', interactive=True) and then prints the axis limits again, revealing that the x-limits expand from approximately (9.5, 20.5) to a range including 0 before the fix. The script then repeats the same pattern for a non-interactive SpanSelector to check whether the problem also appears when _interactive is False. After the code change in _setup_edge_handle, the agent repeatedly reruns reproduce_issue.py (e.g., at steps 25 and 50) to ensure that the axis limits remain unchanged before and after SpanSelector creation. In addition to this primary script, the agent later creates supplementary scripts such as debug_extents.py, test_edge_cases.py, test_vertical.py, test_cursor.py, test_multicursor.py, and test_pr_issue.py to probe related widgets and edge scenarios, but reproduce_issue.py remains the canonical reproduction and verification harness for the original bug.",
  "1.1": "YES",
  "1.2": "At step 11, the agent created reproduce_issue.py to explicitly replicate the axis-limit regression described in the issue. The script constructs a simple Axes, prints its xlim and ylim, creates a SpanSelector (first interactive, then non-interactive), and then prints the limits again to detect any unexpected changes. When the script is run at step 12 before the fix, the output shows that the x-limits change from approximately (9.5, 20.5) to a range including 0 after the interactive SpanSelector is instantiated, confirming the bug. After implementing the fix in _setup_edge_handle at step 24, the agent reruns reproduce_issue.py at step 25 to verify that the xlim and ylim remain identical before and after SpanSelector creation. Near the end of the trajectory, the agent runs reproduce_issue.py one more time at step 50 to double-check that the behavior remains stable even after additional edits and tests. Throughout the session, this script serves both as a regression reproducer and as a quick sanity check that the proposed fix truly prevents axis-limit drift.",
  "Search for the issue": "The model used several grep-based search commands to quickly locate relevant parts of the Matplotlib widgets implementation. Early on, it ran grep -n \"class SpanSelector\" on lib/matplotlib/widgets.py (step 3) to jump directly to the SpanSelector class definition instead of manually scrolling through a large file. It then searched for \"extents\" and \"_draw_shape\" (steps 6 and 8) to understand how the selector’s geometry is represented and updated, which led it to the extents property and the _draw_shape method that control the rectangle’s placement. Later, the agent searched for \"autoscale\" within widgets.py (step 20) while reasoning about how axes limits might be protected from handle creation, although this particular query did not yield an immediate ready-made solution. Additional grep queries for \"ToolLineHandles\", \"axvline|axhline\", and \"xmid|ymid\" (steps 36, 37, and 42) helped the agent inspect how control handles are drawn with axvline/axhline and how midpoints are computed, confirming that these internal lines were responsible for triggering autoscaling. Overall, these search commands played a key role in quickly surfacing the classes, methods, and autoscale-related patterns that needed to be inspected to understand and ultimately fix the issue.",
  "2.1": "YES",
  "2.2": "At step 3, the agent executed grep -n \"class SpanSelector\" /testbed/lib/matplotlib/widgets.py, which returned the line number of the SpanSelector class and allowed it to open the surrounding code region with a targeted view command instead of scanning the file manually. Following that, at step 6 it ran grep -n \"extents\" to find where the extents property is defined and used, which exposed the code path where extents is tied to rectangle geometry and edge handles. At step 8, grep -n \"_draw_shape\" helped locate the helper method that physically updates the rectangle’s position and size, providing context for how the selector’s rectangle and handles interact. Later, when the agent suspected autoscaling side effects, it issued grep -n \"autoscale\" (step 20) in widgets.py to look for any existing patterns for temporarily disabling autoscaling, though it ended up implementing a save/restore of xlim and ylim instead. Subsequent searches for \"ToolLineHandles\" and for \"axvline|axhline\" (steps 36 and 37) revealed that the control handles are created with axvline/axhline in ToolLineHandles.__init__, which strongly supported the hypothesis that line creation was altering axes limits. Finally, grep -B 10 -A 2 \"xmid|ymid\" (step 42) showed how midpoints are computed and used, tying together the handle positions and the autoscale behavior. Together, these search steps provided a structured path through a large codebase and directly contributed to identifying both the root cause and a safe location for the fix.",
  "Edit the Code": "The main code change occurs in the SpanSelector._setup_edge_handle method inside lib/matplotlib/widgets.py at step 24. Originally, this method simply constructed ToolLineHandles with self.ax and self.extents and then extended self.artists with the resulting handle lines, allowing ToolLineHandles’ internal calls to ax.axvline/ax.axhline to run with default autoscaling behavior. To prevent handle creation from altering the main axes limits, the agent modified _setup_edge_handle so that it first saves the current xlim and ylim via xlim = self.ax.get_xlim() and ylim = self.ax.get_ylim(). It then creates the ToolLineHandles instance and extends self.artists as before, but after that it explicitly restores the original limits by calling self.ax.set_xlim(xlim) and self.ax.set_ylim(ylim). This localized change ensures that the SpanSelector still has fully functional interactive handles while guaranteeing that the act of constructing those handles does not change the plot’s data limits. No other functional modifications are made to ToolLineHandles or the selector’s drawing logic; the fix is deliberately scoped to shielding the axes from autoscale side effects during handle setup.",
  "Test changes on the reproduction code": "After implementing the fix in _setup_edge_handle, the agent repeatedly exercised the reproduction and supplemental test scripts to validate the behavior. It first reran reproduce_issue.py at step 25, observing that the xlim and ylim printed before and after creating both interactive and non-interactive SpanSelector instances now matched exactly, demonstrating that axes limits no longer drift on widget construction. The agent then created and executed several additional scripts: debug_extents.py to print internal extents and rectangle positions during handle setup, test_edge_cases.py to check behavior under negative limits and other boundary conditions, and test_vertical.py to examine vertical spans and different orientations. It also prepared test_cursor.py and test_multicursor.py to ensure that related tools such as Cursor and MultiCursor, which may also depend on ToolLineHandles or similar autoscaled lines, did not regress and behaved consistently with fixed axes limits. To further increase confidence, the agent ran pytest on lib/matplotlib/tests/test_widgets.py and related test modules, confirming that existing unit tests continued to pass with the new change. Finally, it re-ran reproduce_issue.py near the end of the trajectory (step 50) as a final sanity check before cleaning up the temporary scripts, confirming once again that the axis limits remained unchanged by SpanSelector creation.",
  "4.1": "YES",
  "4.2": "The reproduction tests and additional scripts all indicated that the fix was successful. When reproduce_issue.py was first run before the code change (step 12), the output showed a clear discrepancy in the x-limits after constructing an interactive SpanSelector, confirming the original bug. After the modification to _setup_edge_handle, rerunning the same script (steps 25 and 50) produced identical xlim and ylim values before and after SpanSelector creation, demonstrating that the handle setup no longer perturbs axes limits. The edge-case and orientation-specific scripts (such as test_edge_cases.py and test_vertical.py) likewise reported stable axis limits across different data ranges, including negative ranges and vertical spans. Cursor and MultiCursor behaviors, exercised via test_cursor.py and test_multicursor.py, continued to work correctly without unexpected zoom or limit changes, suggesting the fix does not introduce regressions in related widgets. Moreover, the pytest run over the existing widget test suite completed without failures, reinforcing that the change is compatible with the broader Matplotlib test corpus and that the bug is robustly resolved.",
  "Tool-use analysis": {
    "str_replace_editor": 26,
    "str_replace_editor:view": 14,
    "grep": 7,
    "str_replace_editor:create": 11,
    "cd": 18,
    "python": 17,
    "str_replace_editor:str_replace": 1,
    "submit": 2,
    "rm": 1
  }
}
