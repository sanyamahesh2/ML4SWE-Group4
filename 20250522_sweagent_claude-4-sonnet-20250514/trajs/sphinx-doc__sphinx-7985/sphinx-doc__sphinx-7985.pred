{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "sphinx-doc__sphinx-7985", "model_patch": "diff --git a/setup.py b/setup.py\nindex a404f1fa5..2c6848797 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):\n     sys.exit(1)\n \n install_requires = [\n-    'sphinxcontrib-applehelp',\n-    'sphinxcontrib-devhelp',\n+    'sphinxcontrib-applehelp<=1.0.7',\n+    'sphinxcontrib-devhelp<=1.0.5',\n     'sphinxcontrib-jsmath',\n-    'sphinxcontrib-htmlhelp',\n-    'sphinxcontrib-serializinghtml',\n-    'sphinxcontrib-qthelp',\n-    'Jinja2>=2.3',\n+    'sphinxcontrib-htmlhelp<=2.0.4',\n+    'sphinxcontrib-serializinghtml<=1.1.9',\n+    'sphinxcontrib-qthelp<=1.0.6',\n+    'Jinja2<3.0',\n     'Pygments>=2.0',\n     'docutils>=0.12',\n     'snowballstemmer>=1.1',\n     'babel>=1.3',\n-    'alabaster>=0.7,<0.8',\n+    'alabaster>=0.7,<0.7.12',\n     'imagesize',\n     'requests>=2.5.0',\n     'setuptools',\n-    'packaging',\n+    'packaging', 'markupsafe<=2.0.1',\n ]\n \n extras_require = {\ndiff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py\nindex dd5317087..4bcfd6fd7 100644\n--- a/sphinx/builders/linkcheck.py\n+++ b/sphinx/builders/linkcheck.py\n@@ -77,7 +77,7 @@ def check_anchor(response: requests.requests.Response, anchor: str) -> bool:\n \n class CheckExternalLinksBuilder(Builder):\n     \"\"\"\n-    Checks for broken external links.\n+    Checks for broken external links and local (internal) links.\n     \"\"\"\n     name = 'linkcheck'\n     epilog = __('Look for any errors in the above output or in '\n@@ -208,12 +208,99 @@ class CheckExternalLinksBuilder(Builder):\n                 else:\n                     return 'redirected', new_url, 0\n \n+        def check_local_uri(uri: str) -> Tuple[str, str, int]:\n+            \"\"\"Check local URI for validity.\"\"\"\n+            # Parse the URI to separate document and anchor parts\n+            if '#' in uri:\n+                doc_part, anchor_part = uri.split('#', 1)\n+            else:\n+                doc_part, anchor_part = uri, None\n+            \n+            # Handle fragment-only links (like #anchor)\n+            if not doc_part and anchor_part:\n+                # This is a fragment-only link, check in current document\n+                if self.app.config.linkcheck_anchors:\n+                    # Check if anchor should be ignored\n+                    for rex in self.anchors_ignore:\n+                        if rex.match(anchor_part):\n+                            return 'working', '', 0\n+                    \n+                    std_domain = self.env.get_domain('std')\n+                    \n+                    # Check in labels (explicit labels with titles)\n+                    if anchor_part in std_domain.labels:\n+                        return 'working', '', 0\n+                    \n+                    # Check in anonlabels (anonymous labels without titles)\n+                    if anchor_part in std_domain.anonlabels:\n+                        return 'working', '', 0\n+                    \n+                    return 'broken', f\"Anchor '{anchor_part}' not found\", 0\n+                else:\n+                    # If anchor checking is disabled, treat fragment-only links as working\n+                    return 'working', '', 0\n+            \n+            # Convert HTML filename to docname (remove .html extension)\n+            if doc_part.endswith('.html'):\n+                docname = doc_part[:-5]  # Remove .html\n+            elif doc_part.endswith('/'):\n+                # Handle directory-style links\n+                docname = doc_part.rstrip('/')\n+            else:\n+                docname = doc_part\n+            \n+            # Handle relative paths - normalize them\n+            if docname.startswith('../') or '/../' in docname:\n+                # For now, we'll treat relative paths as potentially valid\n+                # A more sophisticated implementation could resolve them properly\n+                pass\n+            \n+            # Check if the document exists (only if we have a non-empty docname)\n+            if docname and docname not in self.env.found_docs:\n+                return 'broken', f\"Document '{docname}' not found\", 0\n+            \n+            # If there's an anchor, check if it exists (only if anchor checking is enabled)\n+            if anchor_part:\n+                if self.app.config.linkcheck_anchors:\n+                    # Check if anchor should be ignored\n+                    for rex in self.anchors_ignore:\n+                        if rex.match(anchor_part):\n+                            anchor_part = None\n+                            break\n+                    \n+                    if anchor_part:\n+                        # Get the standard domain to check labels\n+                        std_domain = self.env.get_domain('std')\n+                        \n+                        # Check in labels (explicit labels with titles)\n+                        if anchor_part in std_domain.labels:\n+                            label_docname, label_id, label_title = std_domain.labels[anchor_part]\n+                            if docname and label_docname != docname:\n+                                return 'broken', f\"Anchor '{anchor_part}' not found in document '{docname}'\", 0\n+                            return 'working', '', 0\n+                        \n+                        # Check in anonlabels (anonymous labels without titles)\n+                        if anchor_part in std_domain.anonlabels:\n+                            label_docname, label_id = std_domain.anonlabels[anchor_part]\n+                            if docname and label_docname != docname:\n+                                return 'broken', f\"Anchor '{anchor_part}' not found in document '{docname}'\", 0\n+                            return 'working', '', 0\n+                        \n+                        # If we have a docname but the anchor wasn't found in labels,\n+                        # it might be a section heading or other implicit anchor\n+                        # For now, we'll mark it as broken if we can't find it in the standard domain\n+                        return 'broken', f\"Anchor '{anchor_part}' not found\", 0\n+            \n+            # If we get here, it's a valid document reference without anchor\n+            return 'working', '', 0\n+\n         def check() -> Tuple[str, str, int]:\n             # check for various conditions without bothering the network\n             if len(uri) == 0 or uri.startswith(('#', 'mailto:', 'ftp:')):\n                 return 'unchecked', '', 0\n             elif not uri.startswith(('http:', 'https:')):\n-                return 'local', '', 0\n+                # Check local URIs\n+                return check_local_uri(uri)\n             elif uri in self.good:\n                 return 'working', 'old', 0\n             elif uri in self.broken:\ndiff --git a/tox.ini b/tox.ini\nindex bddd822a6..34baee205 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -27,7 +27,7 @@ extras =\n setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils\n commands=\n-    pytest --durations 25 {posargs}\n+    pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\n"}