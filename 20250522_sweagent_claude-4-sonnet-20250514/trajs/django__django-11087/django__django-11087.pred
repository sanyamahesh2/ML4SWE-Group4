{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-11087", "model_patch": "diff --git a/django/db/models/deletion.py b/django/db/models/deletion.py\nindex 3a462f1c4c..39f572ee26 100644\n--- a/django/db/models/deletion.py\n+++ b/django/db/models/deletion.py\n@@ -220,7 +220,7 @@ class Collector:\n                     sub_objs = self.related_objects(related, batch)\n                     if self.can_fast_delete(sub_objs, from_field=field):\n                         self.fast_deletes.append(sub_objs)\n-                    elif sub_objs:\n+                    elif sub_objs.exists():\n                         field.remote_field.on_delete(self, field, sub_objs, self.using)\n             for field in model._meta.private_fields:\n                 if hasattr(field, 'bulk_related_objects'):\n@@ -232,9 +232,29 @@ class Collector:\n         \"\"\"\n         Get a QuerySet of objects related to `objs` via the relation `related`.\n         \"\"\"\n-        return related.related_model._base_manager.using(self.using).filter(\n+        qs = related.related_model._base_manager.using(self.using).filter(\n             **{\"%s__in\" % related.field.name: objs}\n         )\n+        \n+        # Optimize the queryset to only fetch required fields for deletion.\n+        # We need the primary key for deletion and any foreign key fields\n+        # that might be needed for dependency tracking or signals.\n+        model = related.related_model\n+        only_fields = [model._meta.pk.name]\n+        \n+        # Add foreign key fields that might be needed for cascading deletes\n+        # and dependency tracking\n+        for field in model._meta.get_fields():\n+            if field.many_to_one:\n+                only_fields.append(field.name)\n+        \n+        # Only apply the optimization if there are fields to optimize\n+        # (i.e., if there are fields other than the ones we're selecting)\n+        all_field_names = [f.name for f in model._meta.get_fields() if f.concrete]\n+        if len(only_fields) < len(all_field_names):\n+            return qs.only(*only_fields)\n+        else:\n+            return qs\n \n     def instances_with_model(self):\n         for model, instances in self.data.items():\n"}