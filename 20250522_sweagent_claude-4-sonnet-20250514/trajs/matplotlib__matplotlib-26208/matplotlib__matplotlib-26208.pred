{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "matplotlib__matplotlib-26208", "model_patch": "diff --git a/debug_axisinfo.py b/debug_axisinfo.py\nnew file mode 100644\nindex 0000000000..1c737cc7ae\n--- /dev/null\n+++ b/debug_axisinfo.py\n@@ -0,0 +1,79 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Set up the converter and units\n+import matplotlib.units as munits\n+new_converter = munits.registry.get_converter(df1_index)\n+ax2.xaxis.converter = new_converter\n+default = ax2.xaxis.converter.default_units(df1_index, ax2.xaxis)\n+\n+print(\"\\nBefore _update_axisinfo:\")\n+print_datalim(ax1, ax2)\n+\n+# Let's trace what happens step by step in _update_axisinfo\n+if ax2.xaxis.converter is None:\n+    print(\"Converter is None, returning\")\n+else:\n+    print(\"Getting axisinfo...\")\n+    info = ax2.xaxis.converter.axisinfo(default, ax2.xaxis)\n+    print(f\"Info: {info}\")\n+    \n+    if info is None:\n+        print(\"Info is None, returning\")\n+    else:\n+        print(\"Info is not None, processing...\")\n+        \n+        # Check each part of the info processing\n+        if info.majloc is not None and ax2.xaxis.major.locator != info.majloc and ax2.xaxis.isDefault_majloc:\n+            print(\"Setting major locator...\")\n+            ax2.xaxis.set_major_locator(info.majloc)\n+            print(\"After setting major locator:\")\n+            print_datalim(ax1, ax2)\n+            \n+        if info.minloc is not None and ax2.xaxis.minor.locator != info.minloc and ax2.xaxis.isDefault_minloc:\n+            print(\"Setting minor locator...\")\n+            ax2.xaxis.set_minor_locator(info.minloc)\n+            print(\"After setting minor locator:\")\n+            print_datalim(ax1, ax2)\n+            \n+        if info.majfmt is not None and ax2.xaxis.major.formatter != info.majfmt and ax2.xaxis.isDefault_majfmt:\n+            print(\"Setting major formatter...\")\n+            ax2.xaxis.set_major_formatter(info.majfmt)\n+            print(\"After setting major formatter:\")\n+            print_datalim(ax1, ax2)\n+            \n+        if info.minfmt is not None and ax2.xaxis.minor.formatter != info.minfmt and ax2.xaxis.isDefault_minfmt:\n+            print(\"Setting minor formatter...\")\n+            ax2.xaxis.set_minor_formatter(info.minfmt)\n+            print(\"After setting minor formatter:\")\n+            print_datalim(ax1, ax2)\n+            \n+        if info.label is not None and ax2.xaxis.isDefault_label:\n+            print(\"Setting label...\")\n+            ax2.xaxis.set_label_text(info.label)\n+            print(\"After setting label:\")\n+            print_datalim(ax1, ax2)\n+            \n+        print(\"Calling set_default_intervals...\")\n+        ax2.xaxis.set_default_intervals()\n+        print(\"After set_default_intervals:\")\n+        print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_callback_object.py b/debug_callback_object.py\nnew file mode 100644\nindex 0000000000..6356a70805\n--- /dev/null\n+++ b/debug_callback_object.py\n@@ -0,0 +1,42 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Check what the callback object is\n+callback_ref = ax1.xaxis.callbacks.callbacks['units'][0]\n+callback_obj = callback_ref()\n+print(f\"Callback object: {callback_obj}\")\n+print(f\"Callback object type: {type(callback_obj)}\")\n+\n+# Check if it's a method and what object it belongs to\n+if hasattr(callback_obj, '__self__'):\n+    print(f\"Callback belongs to: {callback_obj.__self__}\")\n+    print(f\"Callback method name: {callback_obj.__name__}\")\n+    \n+# Let's also check ax2\n+callback_ref2 = ax2.xaxis.callbacks.callbacks['units'][0]\n+callback_obj2 = callback_ref2()\n+print(f\"ax2 Callback object: {callback_obj2}\")\n+print(f\"ax2 Callback object type: {type(callback_obj2)}\")\n+\n+if hasattr(callback_obj2, '__self__'):\n+    print(f\"ax2 Callback belongs to: {callback_obj2.__self__}\")\n+    print(f\"ax2 Callback method name: {callback_obj2.__name__}\")\n\\ No newline at end of file\ndiff --git a/debug_callbacks.py b/debug_callbacks.py\nnew file mode 100644\nindex 0000000000..df2df50a2e\n--- /dev/null\n+++ b/debug_callbacks.py\n@@ -0,0 +1,53 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+from matplotlib.category import UnitData\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Check what callbacks are registered\n+print(f\"ax1.xaxis callbacks: {ax1.xaxis.callbacks.callbacks}\")\n+print(f\"ax2.xaxis callbacks: {ax2.xaxis.callbacks.callbacks}\")\n+\n+# Get the new converter\n+import matplotlib.units as munits\n+new_converter = munits.registry.get_converter(df1_index)\n+ax2.xaxis.converter = new_converter\n+\n+# Create UnitData\n+unit_data = UnitData(df1_index)\n+\n+# Set units on both axes manually\n+ax1.xaxis.units = unit_data\n+ax2.xaxis.units = unit_data\n+\n+# Call _update_axisinfo on both\n+ax1.xaxis._update_axisinfo()\n+ax2.xaxis._update_axisinfo()\n+\n+print(\"Before callbacks.process on ax1.xaxis:\")\n+print_datalim(ax1, ax2)\n+\n+ax1.xaxis.callbacks.process('units')\n+print(\"After callbacks.process on ax1.xaxis:\")\n+print_datalim(ax1, ax2)\n+\n+ax2.xaxis.callbacks.process('units')\n+print(\"After callbacks.process on ax2.xaxis:\")\n+print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_converter.py b/debug_converter.py\nnew file mode 100644\nindex 0000000000..42275ceacd\n--- /dev/null\n+++ b/debug_converter.py\n@@ -0,0 +1,40 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Get the new converter\n+import matplotlib.units as munits\n+new_converter = munits.registry.get_converter(df1_index)\n+\n+print(\"Before setting converter:\")\n+print_datalim(ax1, ax2)\n+\n+# Set the converter\n+ax2.xaxis.converter = new_converter\n+print(\"After setting converter:\")\n+print_datalim(ax1, ax2)\n+\n+# Get default units\n+default = ax2.xaxis.converter.default_units(df1_index, ax2.xaxis)\n+print(f\"Default units: {default}\")\n+\n+print(\"After getting default units:\")\n+print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_detailed.py b/debug_detailed.py\nnew file mode 100644\nindex 0000000000..a2982f9f36\n--- /dev/null\n+++ b/debug_detailed.py\n@@ -0,0 +1,57 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Let's trace what happens step by step during plot\n+print(\"\\nCalling ax2.plot step by step:\")\n+\n+# First, let's see what _get_lines does\n+lines = list(ax2._get_lines(df1_index, df2_values))\n+print(\"After _get_lines:\")\n+print_datalim(ax1, ax2)\n+\n+# Now add the line\n+for line in lines:\n+    print(\"Before add_line:\")\n+    print_datalim(ax1, ax2)\n+    ax2.add_line(line)\n+    print(\"After add_line:\")\n+    print_datalim(ax1, ax2)\n+\n+# Now request autoscale\n+print(\"Before _request_autoscale_view('x'):\")\n+print_datalim(ax1, ax2)\n+ax2._request_autoscale_view(\"x\")\n+print(\"After _request_autoscale_view('x'):\")\n+print_datalim(ax1, ax2)\n+\n+print(\"Before _request_autoscale_view('y'):\")\n+print_datalim(ax1, ax2)\n+ax2._request_autoscale_view(\"y\")\n+print(\"After _request_autoscale_view('y'):\")\n+print_datalim(ax1, ax2)\n+\n+# Now let's see what happens when we access viewLim\n+print(\"Before accessing ax2.viewLim:\")\n+print_datalim(ax1, ax2)\n+_ = ax2.viewLim\n+print(\"After accessing ax2.viewLim:\")\n+print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_intervals.py b/debug_intervals.py\nnew file mode 100644\nindex 0000000000..0d408a9754\n--- /dev/null\n+++ b/debug_intervals.py\n@@ -0,0 +1,39 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+def print_mutated(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim.mutatedy(): {ax_.dataLim.mutatedy()}, viewLim.mutatedy(): {ax_.viewLim.mutatedy()}\")\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+print_mutated(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"\\nAfter creating twinx:\")\n+print_datalim(ax1, ax2)\n+print_mutated(ax1, ax2)\n+\n+# Let's see what happens when we call set_default_intervals on ax1.yaxis\n+print(\"\\nCalling ax1.yaxis.set_default_intervals():\")\n+ax1.yaxis.set_default_intervals()\n+print_datalim(ax1, ax2)\n+print_mutated(ax1, ax2)\n+\n+# Let's see what happens when we call set_default_intervals on ax2.yaxis\n+print(\"\\nCalling ax2.yaxis.set_default_intervals():\")\n+ax2.yaxis.set_default_intervals()\n+print_datalim(ax1, ax2)\n+print_mutated(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_issue.py b/debug_issue.py\nnew file mode 100644\nindex 0000000000..b7b371cb05\n--- /dev/null\n+++ b/debug_issue.py\n@@ -0,0 +1,49 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+def print_shared_axes(*ax):\n+    for i, ax_ in enumerate(ax):\n+        shared = ax_._shared_axes[\"x\"].get_siblings(ax_)\n+        print(f\"ax{i+1} shared x-axes: {len(shared)}\")\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+print(\"Initial state:\")\n+print_datalim(ax1)\n+print_shared_axes(ax1)\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"\\nAfter stackplot on ax1:\")\n+print_datalim(ax1)\n+print_shared_axes(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"\\nAfter creating twinx:\")\n+print_datalim(ax1, ax2)\n+print_shared_axes(ax1, ax2)\n+\n+# Let's see what happens when we access viewLim\n+print(\"\\nAccessing ax1.viewLim:\")\n+_ = ax1.viewLim\n+print_datalim(ax1, ax2)\n+\n+print(\"\\nAccessing ax2.viewLim:\")\n+_ = ax2.viewLim\n+print_datalim(ax1, ax2)\n+\n+ax2.plot(df1_index, df2_values)\n+print(\"\\nAfter plot on ax2:\")\n+print_datalim(ax1, ax2)\n+\n+print(\"\\nAccessing ax1.viewLim again:\")\n+_ = ax1.viewLim\n+print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_set_units.py b/debug_set_units.py\nnew file mode 100644\nindex 0000000000..1b1f3dd2ce\n--- /dev/null\n+++ b/debug_set_units.py\n@@ -0,0 +1,40 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+from matplotlib.category import UnitData\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Get the new converter\n+import matplotlib.units as munits\n+new_converter = munits.registry.get_converter(df1_index)\n+ax2.xaxis.converter = new_converter\n+\n+print(\"Before set_units:\")\n+print_datalim(ax1, ax2)\n+\n+# Create UnitData\n+unit_data = UnitData(df1_index)\n+print(\"After creating UnitData:\")\n+print_datalim(ax1, ax2)\n+\n+# Call set_units\n+ax2.xaxis.set_units(unit_data)\n+print(\"After set_units:\")\n+print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_set_units_detailed.py b/debug_set_units_detailed.py\nnew file mode 100644\nindex 0000000000..5ada65a210\n--- /dev/null\n+++ b/debug_set_units_detailed.py\n@@ -0,0 +1,63 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+from matplotlib.category import UnitData\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Get the new converter\n+import matplotlib.units as munits\n+new_converter = munits.registry.get_converter(df1_index)\n+ax2.xaxis.converter = new_converter\n+\n+# Create UnitData\n+unit_data = UnitData(df1_index)\n+\n+print(\"Before set_units:\")\n+print_datalim(ax1, ax2)\n+\n+# Manually trace what happens in set_units\n+u = unit_data\n+if u == ax2.xaxis.units:\n+    print(\"Units are the same, returning\")\n+else:\n+    print(\"Units are different, processing shared axes...\")\n+    shared_axes = ax2.xaxis._get_shared_axis()\n+    print(f\"Shared axes: {len(shared_axes)}\")\n+    \n+    for i, axis in enumerate(shared_axes):\n+        print(f\"Processing axis {i}: {axis}\")\n+        print(f\"Before setting units on axis {i}:\")\n+        print_datalim(ax1, ax2)\n+        \n+        axis.units = u\n+        print(f\"After setting units on axis {i}:\")\n+        print_datalim(ax1, ax2)\n+        \n+        axis._update_axisinfo()\n+        print(f\"After _update_axisinfo on axis {i}:\")\n+        print_datalim(ax1, ax2)\n+        \n+        axis.callbacks.process('units')\n+        print(f\"After callbacks.process on axis {i}:\")\n+        print_datalim(ax1, ax2)\n+        \n+        axis.stale = True\n+        print(f\"After setting stale on axis {i}:\")\n+        print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_stackplot_children.py b/debug_stackplot_children.py\nnew file mode 100644\nindex 0000000000..a0f35cbfef\n--- /dev/null\n+++ b/debug_stackplot_children.py\n@@ -0,0 +1,29 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+\n+fig, ax1 = plt.subplots()\n+\n+print(\"Children before stackplot:\")\n+for i, child in enumerate(ax1._children):\n+    print(f\"  {i}: {type(child)} - {child}\")\n+\n+result = ax1.stackplot(df1_index, df1_values)\n+print(f\"\\nStackplot returned: {result}\")\n+for i, item in enumerate(result):\n+    print(f\"  {i}: {type(item)} - {item}\")\n+\n+print(\"\\nChildren after stackplot:\")\n+for i, child in enumerate(ax1._children):\n+    print(f\"  {i}: {type(child)} - {child}\")\n+    \n+# Check if the stackplot children are patches\n+import matplotlib.patches as mpatches\n+import matplotlib.collections as mcoll\n+\n+for i, child in enumerate(ax1._children):\n+    print(f\"Child {i} is Patch: {isinstance(child, mpatches.Patch)}\")\n+    print(f\"Child {i} is Collection: {isinstance(child, mcoll.Collection)}\")\n+    print(f\"Child {i} is PolyCollection: {isinstance(child, mcoll.PolyCollection)}\")\n\\ No newline at end of file\ndiff --git a/debug_units.py b/debug_units.py\nnew file mode 100644\nindex 0000000000..f94f6a32db\n--- /dev/null\n+++ b/debug_units.py\n@@ -0,0 +1,39 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+def print_units(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} xaxis units: {ax_.xaxis.units}, yaxis units: {ax_.yaxis.units}\")\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+print_units(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"\\nAfter creating twinx:\")\n+print_datalim(ax1, ax2)\n+print_units(ax1, ax2)\n+\n+# Let's see what happens when we call update_units on ax2.yaxis\n+print(\"\\nCalling ax2.yaxis.update_units(df2_values):\")\n+ax2.yaxis.update_units(df2_values)\n+print_datalim(ax1, ax2)\n+print_units(ax1, ax2)\n+\n+# Let's see what happens when we call update_units on ax2.xaxis\n+print(\"\\nCalling ax2.xaxis.update_units(df1_index):\")\n+ax2.xaxis.update_units(df1_index)\n+print_datalim(ax1, ax2)\n+print_units(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_update_units.py b/debug_update_units.py\nnew file mode 100644\nindex 0000000000..be5735c340\n--- /dev/null\n+++ b/debug_update_units.py\n@@ -0,0 +1,59 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+# Let's trace what happens step by step in update_units\n+print(\"\\nBefore ax2.xaxis.update_units:\")\n+print_datalim(ax1, ax2)\n+\n+# Check if converter is different\n+converter = ax2.xaxis.converter\n+print(f\"ax2.xaxis.converter before: {converter}\")\n+\n+# Get the new converter\n+import matplotlib.units as munits\n+new_converter = munits.registry.get_converter(df1_index)\n+print(f\"New converter: {new_converter}\")\n+\n+# Check if they're different\n+neednew = ax2.xaxis.converter != new_converter\n+print(f\"neednew: {neednew}\")\n+\n+# Set the converter\n+ax2.xaxis.converter = new_converter\n+print(\"After setting converter:\")\n+print_datalim(ax1, ax2)\n+\n+# Get default units\n+default = ax2.xaxis.converter.default_units(df1_index, ax2.xaxis)\n+print(f\"Default units: {default}\")\n+\n+# Set units\n+if default is not None and ax2.xaxis.units is None:\n+    print(\"Setting units...\")\n+    ax2.xaxis.set_units(default)\n+    print(\"After setting units:\")\n+    print_datalim(ax1, ax2)\n+elif neednew:\n+    print(\"Calling _update_axisinfo...\")\n+    ax2.xaxis._update_axisinfo()\n+    print(\"After _update_axisinfo:\")\n+    print_datalim(ax1, ax2)\n\\ No newline at end of file\ndiff --git a/debug_zero_case.py b/debug_zero_case.py\nnew file mode 100644\nindex 0000000000..964fff8c69\n--- /dev/null\n+++ b/debug_zero_case.py\n@@ -0,0 +1,20 @@\n+import matplotlib.pyplot as plt\n+import matplotlib.collections as mcoll\n+\n+fig, ax = plt.subplots()\n+\n+# Create a collection with a single point (zero width/height)\n+point_collection = mcoll.LineCollection([[(0, 0), (0, 0)]])\n+ax.add_collection(point_collection)\n+\n+# Check what get_datalim returns\n+datalim = point_collection.get_datalim(ax.transData)\n+print(f\"Collection datalim: {datalim}\")\n+print(f\"Collection datalim width: {datalim.width}\")\n+print(f\"Collection datalim height: {datalim.height}\")\n+print(f\"Collection datalim points: {datalim.get_points()}\")\n+\n+# Check if it's null\n+print(f\"Is null: {datalim.width == 0 and datalim.height == 0}\")\n+\n+plt.close()\n\\ No newline at end of file\ndiff --git a/lib/matplotlib/axes/_base.py b/lib/matplotlib/axes/_base.py\nindex 5203e3232c..4cd0d4f5b8 100644\n--- a/lib/matplotlib/axes/_base.py\n+++ b/lib/matplotlib/axes/_base.py\n@@ -2411,6 +2411,20 @@ class _AxesBase(martist.Artist):\n         xys = trf_to_data.transform(vertices)\n         self.update_datalim(xys, updatex=updatex, updatey=updatey)\n \n+    def _update_collection_limits(self, collection):\n+        \"\"\"Update the data limits for the given collection.\"\"\"\n+        # Get the data limits from the collection\n+        datalim = collection.get_datalim(self.transData)\n+        # Check if it's a null bbox (infinite bounds)\n+        if (np.isinf(datalim.x0) or np.isinf(datalim.y0) or \n+            np.isinf(datalim.x1) or np.isinf(datalim.y1)):\n+            # Null bbox, nothing to update\n+            return\n+        \n+        # Update the axes data limits with the collection's limits\n+        self.dataLim.update_from_data_xy(datalim.get_points(),\n+                                         self.ignore_existing_data_limits)\n+\n     def add_table(self, tab):\n         \"\"\"\n         Add a `.Table` to the Axes; return the table.\n@@ -2472,6 +2486,8 @@ class _AxesBase(martist.Artist):\n                     self._update_patch_limits(artist)\n                 elif isinstance(artist, mimage.AxesImage):\n                     self._update_image_limits(artist)\n+                elif isinstance(artist, mcoll.Collection):\n+                    self._update_collection_limits(artist)\n \n     def update_datalim(self, xys, updatex=True, updatey=True):\n         \"\"\"\ndiff --git a/reproduce_bug.py b/reproduce_bug.py\nnew file mode 100644\nindex 0000000000..ea708a6696\n--- /dev/null\n+++ b/reproduce_bug.py\n@@ -0,0 +1,27 @@\n+import matplotlib.pyplot as plt\n+\n+def print_datalim(*ax):\n+    for ax_ in ax:\n+        print(ax_.dataLim.intervaly, end=' / ')\n+    print()\n+\n+df1_index = ['16 May', '17 May']  # == df2_index\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+ax2.plot(df1_index, df2_values)\n+print(\"After plot on ax2:\")\n+print_datalim(ax1, ax2)\n+\n+print(\"\\nExpected: ax1 dataLims should remain unchanged\")\n+print(\"Actual: ax1 dataLims get changed to \u00b1inf\")\n\\ No newline at end of file\ndiff --git a/test_edge_cases.py b/test_edge_cases.py\nnew file mode 100644\nindex 0000000000..35e06d5f45\n--- /dev/null\n+++ b/test_edge_cases.py\n@@ -0,0 +1,63 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import matplotlib.collections as mcoll\n+import matplotlib.transforms as mtransforms\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+# Test edge case: Collection with null data limits\n+print(\"=== Test: Collection with null data limits ===\")\n+fig, ax = plt.subplots()\n+\n+# Create a collection with no data\n+empty_collection = mcoll.LineCollection([])\n+ax.add_collection(empty_collection)\n+\n+print(\"Before relim:\")\n+print_datalim(ax)\n+\n+ax.relim()\n+print(\"After relim:\")\n+print_datalim(ax)\n+\n+plt.close()\n+\n+# Test edge case: Collection with zero width/height\n+print(\"\\n=== Test: Collection with zero width/height ===\")\n+fig, ax = plt.subplots()\n+\n+# Create a collection with a single point (zero width/height)\n+point_collection = mcoll.LineCollection([[(0, 0), (0, 0)]])\n+ax.add_collection(point_collection)\n+\n+print(\"Before relim:\")\n+print_datalim(ax)\n+\n+ax.relim()\n+print(\"After relim:\")\n+print_datalim(ax)\n+\n+plt.close()\n+\n+# Test edge case: Mixed artists (lines, patches, collections)\n+print(\"\\n=== Test: Mixed artists ===\")\n+fig, ax = plt.subplots()\n+\n+# Add different types of artists\n+ax.plot([1, 2, 3], [1, 2, 3], label='line')\n+ax.add_patch(plt.Rectangle((0.5, 0.5), 1, 1))\n+ax.stackplot([1, 2, 3], [0.5, 1.5, 2.5])\n+\n+print(\"Before relim:\")\n+print_datalim(ax)\n+\n+ax.relim()\n+print(\"After relim:\")\n+print_datalim(ax)\n+\n+plt.close()\n+\n+print(\"\\nEdge case tests completed!\")\n\\ No newline at end of file\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..d8f56279aa\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,80 @@\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def print_datalim(*ax):\n+    for i, ax_ in enumerate(ax):\n+        print(f\"ax{i+1} dataLim: {ax_.dataLim.intervaly}\", end=' / ')\n+    print()\n+\n+# Test 1: Original bug case\n+print(\"=== Test 1: Original bug case ===\")\n+df1_index = ['16 May', '17 May']\n+df1_values = [-22.717708333333402, 26.584999999999937]\n+df2_values = [-0.08501399999999998, -2.9833019999999966]\n+\n+fig, ax1 = plt.subplots()\n+ax1.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+ax2.plot(df1_index, df2_values)\n+print(\"After plot on ax2:\")\n+print_datalim(ax1, ax2)\n+\n+plt.close()\n+\n+# Test 2: Reverse order (plot first, then stackplot)\n+print(\"\\n=== Test 2: Reverse order ===\")\n+fig, ax1 = plt.subplots()\n+ax1.plot(df1_index, df2_values)\n+print(\"After plot on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()\n+print(\"After creating twinx:\")\n+print_datalim(ax1, ax2)\n+\n+ax2.stackplot(df1_index, df1_values)\n+print(\"After stackplot on ax2:\")\n+print_datalim(ax1, ax2)\n+\n+plt.close()\n+\n+# Test 3: Multiple stackplots\n+print(\"\\n=== Test 3: Multiple stackplots ===\")\n+fig, ax1 = plt.subplots()\n+ax1.stackplot(df1_index, df1_values)\n+ax1.stackplot(df1_index, [x/2 for x in df1_values])\n+print(\"After two stackplots on ax1:\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()\n+ax2.plot(df1_index, df2_values)\n+print(\"After plot on ax2:\")\n+print_datalim(ax1, ax2)\n+\n+plt.close()\n+\n+# Test 4: Numeric data (should not trigger the bug)\n+print(\"\\n=== Test 4: Numeric data ===\")\n+x_numeric = [1, 2, 3]\n+y1_numeric = [10, 20, 15]\n+y2_numeric = [5, 8, 6]\n+\n+fig, ax1 = plt.subplots()\n+ax1.stackplot(x_numeric, y1_numeric)\n+print(\"After stackplot on ax1 (numeric):\")\n+print_datalim(ax1)\n+\n+ax2 = ax1.twinx()\n+ax2.plot(x_numeric, y2_numeric)\n+print(\"After plot on ax2 (numeric):\")\n+print_datalim(ax1, ax2)\n+\n+plt.close()\n+\n+print(\"\\nAll tests completed!\")\n\\ No newline at end of file\n"}