{"model_name_or_path": "250522_anthropic_filemap_simple_review__claude-sonnet-4-20250514__t-0.00__p-1.00__c-3.00___swe_bench_verified_test", "instance_id": "django__django-15280", "model_patch": "diff --git a/debug_issue.py b/debug_issue.py\nnew file mode 100644\nindex 0000000000..db032b3cb3\n--- /dev/null\n+++ b/debug_issue.py\n@@ -0,0 +1,142 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Debug script to understand the deferred fields issue with prefetch_related.\n+\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            '__main__',  # This module\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Prefetch\n+from django.db import connection\n+\n+\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+def debug_issue():\n+    \"\"\"Debug the issue step by step.\"\"\"\n+    from django.db import connection\n+    \n+    # Create tables manually for this test\n+    user_sql = \"\"\"\n+    CREATE TABLE \"__main___user\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"email\" varchar(254) NOT NULL,\n+        \"kind\" varchar(10) NOT NULL\n+    )\n+    \"\"\"\n+    \n+    profile_sql = \"\"\"\n+    CREATE TABLE \"__main___profile\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"full_name\" varchar(255) NOT NULL,\n+        \"user_id\" integer NOT NULL UNIQUE REFERENCES \"__main___user\" (\"id\") DEFERRABLE INITIALLY DEFERRED\n+    )\n+    \"\"\"\n+    \n+    with connection.cursor() as cursor:\n+        try:\n+            cursor.execute(user_sql)\n+            cursor.execute(profile_sql)\n+        except Exception as e:\n+            # Tables might already exist\n+            pass\n+    \n+    # Create test data\n+    user = User.objects.create(\n+        email=\"test@example.com\",\n+        kind=\"ADMIN\",\n+    )\n+    Profile.objects.create(user=user, full_name=\"Test Tester\")\n+    \n+    print(\"=== Testing individual querysets ===\")\n+    \n+    # Test 1: Main queryset only\n+    print(\"\\n1. Main queryset with only('email'):\")\n+    main_qs = User.objects.only(\"email\")\n+    main_user = main_qs.first()\n+    print(f\"   Deferred fields: {main_user.get_deferred_fields()}\")\n+    print(f\"   Fields in __dict__: {set(main_user.__dict__.keys()) & {'email', 'kind'}}\")\n+    \n+    # Test 2: Prefetch queryset only\n+    print(\"\\n2. Prefetch queryset with only('kind'):\")\n+    prefetch_qs = User.objects.only(\"kind\")\n+    prefetch_user = prefetch_qs.first()\n+    print(f\"   Deferred fields: {prefetch_user.get_deferred_fields()}\")\n+    print(f\"   Fields in __dict__: {set(prefetch_user.__dict__.keys()) & {'email', 'kind'}}\")\n+    \n+    print(\"\\n=== Testing prefetch_related ===\")\n+    \n+    # Test 3: The problematic case\n+    print(\"\\n3. Combined queryset with prefetch_related:\")\n+    queryset = User.objects.only(\"email\").prefetch_related(\n+        Prefetch(\n+            \"profile\",\n+            queryset=Profile.objects.prefetch_related(\n+                Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+            ),\n+        )\n+    )\n+    \n+    print(\"   Executing main queryset...\")\n+    user = queryset.first()\n+    print(f\"   Main user deferred fields: {user.get_deferred_fields()}\")\n+    print(f\"   Main user fields in __dict__: {set(user.__dict__.keys()) & {'email', 'kind'}}\")\n+    \n+    print(f\"   Profile user deferred fields: {user.profile.user.get_deferred_fields()}\")\n+    print(f\"   Profile user fields in __dict__: {set(user.profile.user.__dict__.keys()) & {'email', 'kind'}}\")\n+    \n+    # Check if they are the same object\n+    print(f\"   Are they the same object? {user is user.profile.user}\")\n+    print(f\"   Are they equal? {user == user.profile.user}\")\n+    print(f\"   Main user id: {id(user)}\")\n+    print(f\"   Profile user id: {id(user.profile.user)}\")\n+    \n+    # Test accessing the kind field\n+    print(\"\\n   Accessing user.profile.user.kind...\")\n+    queries_before = len(connection.queries)\n+    kind = user.profile.user.kind\n+    queries_after = len(connection.queries)\n+    print(f\"   Queries executed: {queries_after - queries_before}\")\n+    print(f\"   Kind value: {kind}\")\n+\n+\n+if __name__ == \"__main__\":\n+    debug_issue()\n\\ No newline at end of file\ndiff --git a/detailed_trace.py b/detailed_trace.py\nnew file mode 100644\nindex 0000000000..3278ed1bb9\n--- /dev/null\n+++ b/detailed_trace.py\n@@ -0,0 +1,155 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Detailed trace script to understand exactly when object replacement happens.\n+\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            '__main__',  # This module\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Prefetch\n+from django.db import connection\n+\n+\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+# Monkey patch to trace object creation and caching\n+original_from_db = User.from_db\n+created_objects = {}\n+\n+@classmethod\n+def traced_from_db(cls, db, field_names, values):\n+    obj = original_from_db(db, field_names, values)\n+    obj_id = id(obj)\n+    created_objects[obj.pk] = (obj_id, field_names, obj.get_deferred_fields())\n+    print(f\"User.from_db: pk={obj.pk}, id={obj_id}, field_names={field_names}, deferred={obj.get_deferred_fields()}\")\n+    return obj\n+\n+User.from_db = traced_from_db\n+\n+# Monkey patch set_cached_value to trace caching\n+from django.db.models.fields.mixins import FieldCacheMixin\n+original_set_cached_value = FieldCacheMixin.set_cached_value\n+\n+def traced_set_cached_value(self, instance, value):\n+    instance_class = instance.__class__.__name__ if hasattr(instance, '__class__') else type(instance).__name__\n+    value_class = value.__class__.__name__ if hasattr(value, '__class__') else type(value).__name__\n+    instance_pk = getattr(instance, 'pk', None)\n+    value_pk = getattr(value, 'pk', None)\n+    print(f\"set_cached_value: field={self.name}, instance={instance_class}(pk={instance_pk}), value={value_class}(pk={value_pk}, id={id(value)})\")\n+    return original_set_cached_value(self, instance, value)\n+\n+FieldCacheMixin.set_cached_value = traced_set_cached_value\n+\n+\n+def detailed_trace():\n+    \"\"\"Detailed trace of the issue.\"\"\"\n+    from django.db import connection\n+    \n+    # Create tables manually for this test\n+    user_sql = \"\"\"\n+    CREATE TABLE \"__main___user\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"email\" varchar(254) NOT NULL,\n+        \"kind\" varchar(10) NOT NULL\n+    )\n+    \"\"\"\n+    \n+    profile_sql = \"\"\"\n+    CREATE TABLE \"__main___profile\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"full_name\" varchar(255) NOT NULL,\n+        \"user_id\" integer NOT NULL UNIQUE REFERENCES \"__main___user\" (\"id\") DEFERRABLE INITIALLY DEFERRED\n+    )\n+    \"\"\"\n+    \n+    with connection.cursor() as cursor:\n+        try:\n+            cursor.execute(user_sql)\n+            cursor.execute(profile_sql)\n+        except Exception as e:\n+            # Tables might already exist\n+            pass\n+    \n+    # Create test data\n+    user = User.objects.create(\n+        email=\"test@example.com\",\n+        kind=\"ADMIN\",\n+    )\n+    Profile.objects.create(user=user, full_name=\"Test Tester\")\n+    \n+    print(\"=== Detailed trace of prefetch_related execution ===\")\n+    \n+    queryset = User.objects.only(\"email\").prefetch_related(\n+        Prefetch(\n+            \"profile\",\n+            queryset=Profile.objects.prefetch_related(\n+                Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+            ),\n+        )\n+    )\n+    \n+    print(\"\\nExecuting main queryset...\")\n+    user = queryset.first()\n+    \n+    print(f\"\\nAfter main queryset execution:\")\n+    print(f\"Main user object: pk={user.pk}, id={id(user)}\")\n+    print(f\"Main user deferred fields: {user.get_deferred_fields()}\")\n+    \n+    print(f\"\\nAccessing profile...\")\n+    profile = user.profile\n+    \n+    print(f\"\\nAccessing profile.user...\")\n+    profile_user = profile.user\n+    \n+    print(f\"\\nAfter accessing profile.user:\")\n+    print(f\"Profile user object: pk={profile_user.pk}, id={id(profile_user)}\")\n+    print(f\"Profile user deferred fields: {profile_user.get_deferred_fields()}\")\n+    \n+    print(f\"\\nObject identity check:\")\n+    print(f\"user is profile_user: {user is profile_user}\")\n+    \n+    print(f\"\\nCreated objects summary:\")\n+    for pk, (obj_id, field_names, deferred) in created_objects.items():\n+        print(f\"  pk={pk}, id={obj_id}, field_names={field_names}, deferred={deferred}\")\n+\n+\n+if __name__ == \"__main__\":\n+    detailed_trace()\n\\ No newline at end of file\ndiff --git a/django/db/models/fields/related_descriptors.py b/django/db/models/fields/related_descriptors.py\nindex d5aa968400..b2c5f39bec 100644\n--- a/django/db/models/fields/related_descriptors.py\n+++ b/django/db/models/fields/related_descriptors.py\n@@ -193,6 +193,45 @@ class ForwardManyToOneDescriptor:\n                     remote_field.set_cached_value(rel_obj, instance)\n             self.field.set_cached_value(instance, rel_obj)\n \n+        # Check if the related object might have been fetched with different\n+        # field selections in a prefetch operation. If so, try to find a version\n+        # with more complete field information.\n+        if rel_obj is not None and hasattr(rel_obj, '_state') and hasattr(instance, '_state'):\n+            # Look for the related object in the instance's field cache\n+            # This handles cases where prefetch_related has fetched the object\n+            # with different field selections\n+            cache_name = self.field.get_cache_name()\n+            if cache_name in instance._state.fields_cache:\n+                cached_rel_obj = instance._state.fields_cache[cache_name]\n+                if (hasattr(cached_rel_obj, 'pk') and hasattr(rel_obj, 'pk') and\n+                    cached_rel_obj.pk == rel_obj.pk and cached_rel_obj is not rel_obj):\n+                    \n+                    # We have two different instances of the same object.\n+                    # Merge field information to prevent deferred field issues.\n+                    cached_fields = set(cached_rel_obj.__dict__.keys())\n+                    rel_obj_fields = set(rel_obj.__dict__.keys())\n+                    \n+                    # Use the object with more fields, or merge them\n+                    if len(cached_fields) > len(rel_obj_fields):\n+                        # Copy missing fields from rel_obj to cached_rel_obj\n+                        for field_name in rel_obj_fields - cached_fields:\n+                            try:\n+                                setattr(cached_rel_obj, field_name, getattr(rel_obj, field_name))\n+                            except:\n+                                pass\n+                        rel_obj = cached_rel_obj\n+                    else:\n+                        # Copy missing fields from cached_rel_obj to rel_obj\n+                        for field_name in cached_fields - rel_obj_fields:\n+                            try:\n+                                setattr(rel_obj, field_name, getattr(cached_rel_obj, field_name))\n+                            except:\n+                                pass\n+                    \n+                    # Update both caches to use the merged object\n+                    self.field.set_cached_value(instance, rel_obj)\n+                    instance._state.fields_cache[cache_name] = rel_obj\n+\n         if rel_obj is None and not self.field.null:\n             raise self.RelatedObjectDoesNotExist(\n                 \"%s has no %s.\" % (self.field.model.__name__, self.field.name)\ndiff --git a/final_trace.py b/final_trace.py\nnew file mode 100644\nindex 0000000000..cb02369022\n--- /dev/null\n+++ b/final_trace.py\n@@ -0,0 +1,222 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Final trace script to understand exactly when object replacement happens.\n+\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            '__main__',  # This module\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Prefetch\n+from django.db import connection\n+\n+\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+# Monkey patch to trace object creation and caching\n+original_from_db = User.from_db\n+created_objects = {}\n+\n+@classmethod\n+def traced_from_db(cls, db, field_names, values):\n+    obj = original_from_db(db, field_names, values)\n+    obj_id = id(obj)\n+    created_objects[obj.pk] = (obj_id, field_names, obj.get_deferred_fields())\n+    print(f\"User.from_db: pk={obj.pk}, id={obj_id}, field_names={field_names}, deferred={obj.get_deferred_fields()}\")\n+    return obj\n+\n+User.from_db = traced_from_db\n+\n+# Monkey patch __set__ method to trace assignment\n+from django.db.models.fields.related_descriptors import ForwardManyToOneDescriptor\n+original_set = ForwardManyToOneDescriptor.__set__\n+\n+def traced_set(self, instance, value):\n+    instance_class = instance.__class__.__name__ if hasattr(instance, '__class__') else type(instance).__name__\n+    value_class = value.__class__.__name__ if hasattr(value, '__class__') else type(value).__name__\n+    instance_pk = getattr(instance, 'pk', None)\n+    value_pk = getattr(value, 'pk', None)\n+    print(f\"ForwardManyToOneDescriptor.__set__: field={self.field.name}, instance={instance_class}(pk={instance_pk}), value={value_class}(pk={value_pk}, id={id(value)})\")\n+    result = original_set(self, instance, value)\n+    print(f\"  After __set__, cached value id: {id(self.field.get_cached_value(instance))}\")\n+    return result\n+\n+ForwardManyToOneDescriptor.__set__ = traced_set\n+\n+# Monkey patch __get__ method to trace access\n+original_get = ForwardManyToOneDescriptor.__get__\n+\n+def traced_get(self, instance, cls=None):\n+    if instance is None:\n+        return self\n+    \n+    instance_class = instance.__class__.__name__ if hasattr(instance, '__class__') else type(instance).__name__\n+    instance_pk = getattr(instance, 'pk', None)\n+    print(f\"ForwardManyToOneDescriptor.__get__: field={self.field.name}, instance={instance_class}(pk={instance_pk})\")\n+    \n+    # Check what's in the field cache\n+    try:\n+        cached_value = self.field.get_cached_value(instance)\n+        print(f\"  Cached value: pk={getattr(cached_value, 'pk', None)}, id={id(cached_value)}\")\n+    except:\n+        print(f\"  No cached value\")\n+    \n+    result = original_get(self, instance, cls)\n+    \n+    if hasattr(result, 'pk'):\n+        print(f\"  Returning: pk={result.pk}, id={id(result)}, deferred={result.get_deferred_fields()}\")\n+    \n+    return result\n+\n+ForwardManyToOneDescriptor.__get__ = traced_get\n+\n+# Monkey patch prefetch_one_level to trace object assignment\n+from django.db.models.query import prefetch_one_level as original_prefetch_one_level\n+\n+def traced_prefetch_one_level(instances, prefetcher, lookup, level):\n+    print(f\"\\nprefetch_one_level called: level={level}\")\n+    \n+    # Call the original function but trace the assignment\n+    rel_qs, rel_obj_attr, instance_attr, single, cache_name, is_descriptor = (\n+        prefetcher.get_prefetch_queryset(instances, lookup.get_current_queryset(level)))\n+    \n+    all_related_objects = list(rel_qs)\n+    print(f\"all_related_objects: {len(all_related_objects)} objects\")\n+    for i, obj in enumerate(all_related_objects):\n+        if hasattr(obj, 'pk') and obj.__class__.__name__ == 'User':\n+            print(f\"  Object {i}: pk={obj.pk}, id={id(obj)}, deferred={obj.get_deferred_fields()}\")\n+    \n+    rel_obj_cache = {}\n+    for rel_obj in all_related_objects:\n+        rel_attr_val = rel_obj_attr(rel_obj)\n+        rel_obj_cache.setdefault(rel_attr_val, []).append(rel_obj)\n+    \n+    print(f\"rel_obj_cache: {rel_obj_cache}\")\n+    \n+    for obj in instances:\n+        instance_attr_val = instance_attr(obj)\n+        vals = rel_obj_cache.get(instance_attr_val, [])\n+        print(f\"For instance {obj.__class__.__name__}(pk={getattr(obj, 'pk', None)}, id={id(obj)}), vals: {len(vals)} objects\")\n+        \n+        if single:\n+            val = vals[0] if vals else None\n+            if val and hasattr(val, 'pk') and val.__class__.__name__ == 'User':\n+                print(f\"  Assigning val: pk={val.pk}, id={id(val)}, deferred={val.get_deferred_fields()}\")\n+            \n+            print(f\"  cache_name: {cache_name}, is_descriptor: {is_descriptor}\")\n+            if is_descriptor:\n+                print(f\"  Before assignment, obj.__dict__: {obj.__dict__}\")\n+                setattr(obj, cache_name, val)\n+                print(f\"  After assignment, obj.__dict__: {obj.__dict__}\")\n+                print(f\"  Assigned via setattr(obj, {cache_name}, val)\")\n+            else:\n+                print(f\"  Assigning to field cache: obj._state.fields_cache[{cache_name}] = val\")\n+                print(f\"  Before assignment, field cache: {obj._state.fields_cache.get(cache_name, 'NOT_FOUND')}\")\n+                obj._state.fields_cache[cache_name] = val\n+                print(f\"  After assignment, field cache: {obj._state.fields_cache.get(cache_name, 'NOT_FOUND')}\")\n+                if hasattr(obj._state.fields_cache.get(cache_name), 'pk'):\n+                    cached_obj = obj._state.fields_cache[cache_name]\n+                    print(f\"    Cached object: pk={cached_obj.pk}, id={id(cached_obj)}\")\n+    \n+    return all_related_objects, []\n+\n+# Replace the function\n+import django.db.models.query\n+django.db.models.query.prefetch_one_level = traced_prefetch_one_level\n+\n+\n+def final_trace():\n+    \"\"\"Final trace of the issue.\"\"\"\n+    from django.db import connection\n+    \n+    # Create tables manually for this test\n+    user_sql = \"\"\"\n+    CREATE TABLE \"__main___user\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"email\" varchar(254) NOT NULL,\n+        \"kind\" varchar(10) NOT NULL\n+    )\n+    \"\"\"\n+    \n+    profile_sql = \"\"\"\n+    CREATE TABLE \"__main___profile\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"full_name\" varchar(255) NOT NULL,\n+        \"user_id\" integer NOT NULL UNIQUE REFERENCES \"__main___user\" (\"id\") DEFERRABLE INITIALLY DEFERRED\n+    )\n+    \"\"\"\n+    \n+    with connection.cursor() as cursor:\n+        try:\n+            cursor.execute(user_sql)\n+            cursor.execute(profile_sql)\n+        except Exception as e:\n+            # Tables might already exist\n+            pass\n+    \n+    # Create test data\n+    user = User.objects.create(\n+        email=\"test@example.com\",\n+        kind=\"ADMIN\",\n+    )\n+    Profile.objects.create(user=user, full_name=\"Test Tester\")\n+    \n+    print(\"=== Final trace of prefetch_related execution ===\")\n+    \n+    queryset = User.objects.only(\"email\").prefetch_related(\n+        Prefetch(\n+            \"profile\",\n+            queryset=Profile.objects.prefetch_related(\n+                Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+            ),\n+        )\n+    )\n+    \n+    print(\"\\nExecuting main queryset...\")\n+    user = queryset.first()\n+    \n+    print(f\"\\nFinal result:\")\n+    print(f\"Main user object: pk={user.pk}, id={id(user)}\")\n+    print(f\"Profile user object: pk={user.profile.user.pk}, id={id(user.profile.user)}\")\n+    print(f\"Are they the same? {user is user.profile.user}\")\n+\n+\n+if __name__ == \"__main__\":\n+    final_trace()\n\\ No newline at end of file\ndiff --git a/reproduce_issue.py b/reproduce_issue.py\nnew file mode 100644\nindex 0000000000..b5230425bf\n--- /dev/null\n+++ b/reproduce_issue.py\n@@ -0,0 +1,141 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Script to reproduce the deferred fields issue with prefetch_related.\n+\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+from django.test.utils import get_runner\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            '__main__',  # This module\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Prefetch\n+from django.test import TestCase\n+from django.test.utils import override_settings\n+\n+\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+def test_only_related_queryset():\n+    \"\"\"Test case that reproduces the issue.\"\"\"\n+    from django.db import connection\n+    from django.core.management import execute_from_command_line\n+    \n+    # Create tables using Django's migration system\n+    from django.core.management.commands.migrate import Command as MigrateCommand\n+    from django.core.management.commands.makemigrations import Command as MakeMigrationsCommand\n+    from django.core.management import call_command\n+    \n+    # Create tables manually for this test\n+    user_sql = \"\"\"\n+    CREATE TABLE \"__main___user\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"email\" varchar(254) NOT NULL,\n+        \"kind\" varchar(10) NOT NULL\n+    )\n+    \"\"\"\n+    \n+    profile_sql = \"\"\"\n+    CREATE TABLE \"__main___profile\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"full_name\" varchar(255) NOT NULL,\n+        \"user_id\" integer NOT NULL UNIQUE REFERENCES \"__main___user\" (\"id\") DEFERRABLE INITIALLY DEFERRED\n+    )\n+    \"\"\"\n+    \n+    with connection.cursor() as cursor:\n+        try:\n+            cursor.execute(user_sql)\n+            cursor.execute(profile_sql)\n+        except Exception as e:\n+            # Tables might already exist\n+            pass\n+    \n+    # Create test data\n+    user = User.objects.create(\n+        email=\"test@example.com\",\n+        kind=\"ADMIN\",\n+    )\n+    Profile.objects.create(user=user, full_name=\"Test Tester\")\n+    \n+    # Test the problematic queryset\n+    queryset = User.objects.only(\"email\").prefetch_related(\n+        Prefetch(\n+            \"profile\",\n+            queryset=Profile.objects.prefetch_related(\n+                Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+            ),\n+        )\n+    )\n+    \n+    print(\"Executing main queryset...\")\n+    # Track queries\n+    initial_queries = len(connection.queries)\n+    user = queryset.first()\n+    queries_after_first = len(connection.queries)\n+    \n+    print(f\"Queries executed during main queryset: {queries_after_first - initial_queries}\")\n+    for i, query in enumerate(connection.queries[initial_queries:queries_after_first], 1):\n+        print(f\"  {i}. {query['sql']}\")\n+    \n+    print(f\"\\nDeferred fields on user.profile.user: {user.profile.user.get_deferred_fields()}\")\n+    \n+    print(\"\\nAccessing user.profile.user.kind...\")\n+    # This should not execute any queries since kind was fetched in the prefetch\n+    queries_before_access = len(connection.queries)\n+    kind = user.profile.user.kind\n+    queries_after_access = len(connection.queries)\n+    \n+    print(f\"Queries executed when accessing kind: {queries_after_access - queries_before_access}\")\n+    if queries_after_access > queries_before_access:\n+        for i, query in enumerate(connection.queries[queries_before_access:queries_after_access], 1):\n+            print(f\"  {i}. {query['sql']}\")\n+    \n+    print(f\"Kind value: {kind}\")\n+    \n+    return queries_after_access - queries_before_access == 0\n+\n+\n+if __name__ == \"__main__\":\n+    success = test_only_related_queryset()\n+    if success:\n+        print(\"\\n\u2705 Test passed - no extra queries executed!\")\n+    else:\n+        print(\"\\n\u274c Test failed - extra queries were executed!\")\n+        sys.exit(1)\n\\ No newline at end of file\ndiff --git a/trace_issue.py b/trace_issue.py\nnew file mode 100644\nindex 0000000000..8ab92d44ce\n--- /dev/null\n+++ b/trace_issue.py\n@@ -0,0 +1,123 @@\n+#!/usr/bin/env python\n+\"\"\"\n+Trace script to understand exactly where the object reuse happens.\n+\"\"\"\n+import os\n+import sys\n+import django\n+from django.conf import settings\n+\n+# Configure Django settings\n+if not settings.configured:\n+    settings.configure(\n+        DEBUG=True,\n+        DATABASES={\n+            'default': {\n+                'ENGINE': 'django.db.backends.sqlite3',\n+                'NAME': ':memory:',\n+            }\n+        },\n+        INSTALLED_APPS=[\n+            'django.contrib.contenttypes',\n+            'django.contrib.auth',\n+            '__main__',  # This module\n+        ],\n+        SECRET_KEY='test-secret-key',\n+    )\n+\n+django.setup()\n+\n+from django.db import models\n+from django.db.models import Prefetch\n+from django.db import connection\n+\n+\n+class User(models.Model):\n+    email = models.EmailField()\n+    kind = models.CharField(\n+        max_length=10, choices=[(\"ADMIN\", \"Admin\"), (\"REGULAR\", \"Regular\")]\n+    )\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+class Profile(models.Model):\n+    full_name = models.CharField(max_length=255)\n+    user = models.OneToOneField(User, on_delete=models.CASCADE)\n+    \n+    class Meta:\n+        app_label = '__main__'\n+\n+\n+# Monkey patch to trace object creation\n+original_from_db = User.from_db\n+\n+@classmethod\n+def traced_from_db(cls, db, field_names, values):\n+    obj = original_from_db(db, field_names, values)\n+    print(f\"User.from_db called: id={obj.pk}, field_names={field_names}, deferred={obj.get_deferred_fields()}\")\n+    return obj\n+\n+User.from_db = traced_from_db\n+\n+\n+def trace_issue():\n+    \"\"\"Trace the issue step by step.\"\"\"\n+    from django.db import connection\n+    \n+    # Create tables manually for this test\n+    user_sql = \"\"\"\n+    CREATE TABLE \"__main___user\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"email\" varchar(254) NOT NULL,\n+        \"kind\" varchar(10) NOT NULL\n+    )\n+    \"\"\"\n+    \n+    profile_sql = \"\"\"\n+    CREATE TABLE \"__main___profile\" (\n+        \"id\" integer NOT NULL PRIMARY KEY AUTOINCREMENT,\n+        \"full_name\" varchar(255) NOT NULL,\n+        \"user_id\" integer NOT NULL UNIQUE REFERENCES \"__main___user\" (\"id\") DEFERRABLE INITIALLY DEFERRED\n+    )\n+    \"\"\"\n+    \n+    with connection.cursor() as cursor:\n+        try:\n+            cursor.execute(user_sql)\n+            cursor.execute(profile_sql)\n+        except Exception as e:\n+            # Tables might already exist\n+            pass\n+    \n+    # Create test data\n+    user = User.objects.create(\n+        email=\"test@example.com\",\n+        kind=\"ADMIN\",\n+    )\n+    Profile.objects.create(user=user, full_name=\"Test Tester\")\n+    \n+    print(\"=== Tracing prefetch_related execution ===\")\n+    \n+    queryset = User.objects.only(\"email\").prefetch_related(\n+        Prefetch(\n+            \"profile\",\n+            queryset=Profile.objects.prefetch_related(\n+                Prefetch(\"user\", queryset=User.objects.only(\"kind\"))\n+            ),\n+        )\n+    )\n+    \n+    print(\"\\nExecuting main queryset...\")\n+    user = queryset.first()\n+    \n+    print(f\"\\nMain user object: id={id(user)}, pk={user.pk}\")\n+    print(f\"Main user deferred fields: {user.get_deferred_fields()}\")\n+    \n+    print(f\"\\nProfile user object: id={id(user.profile.user)}, pk={user.profile.user.pk}\")\n+    print(f\"Profile user deferred fields: {user.profile.user.get_deferred_fields()}\")\n+\n+\n+if __name__ == \"__main__\":\n+    trace_issue()\n\\ No newline at end of file\n"}